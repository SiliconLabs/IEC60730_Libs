<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IEC60730 Library: IRQ Check</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IEC60730 Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">IRQ Check<div class="ingroups"><a class="el" href="group__efr32__iec60730.html">EFR32 IEC60730 Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Verifies interrupt frequency is within bounds.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsl__iec60730__irq__execution__bounds__t.html">sl_iec60730_irq_execution_bounds_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsl__iec60730__irq__fail__t.html">sl_iec60730_irq_fail_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsl__iec60730__irq__cfg__t.html">sl_iec60730_irq_cfg_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa427cc722316d7c8063ec6e66b21b978"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IEC60730__IRQ__TEST.html#gaa427cc722316d7c8063ec6e66b21b978">IEC60730_MAX_IRQ_CHECK</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:gaa427cc722316d7c8063ec6e66b21b978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga250b6bcca9d228896d7b75299cc33ac0"><td class="memItemLeft" align="right" valign="top"><a id="ga250b6bcca9d228896d7b75299cc33ac0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IEC60730__IRQ__TEST.html#ga250b6bcca9d228896d7b75299cc33ac0">SL_IEC60730_IRQ_TYPE_VARIABLE</a>&#160;&#160;&#160;uint8_t</td></tr>
<tr class="memdesc:ga250b6bcca9d228896d7b75299cc33ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for iec60730_IRQExecCount variables. <br /></td></tr>
<tr class="separator:ga250b6bcca9d228896d7b75299cc33ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a4019f06050d48db420acb0811991d5"><td class="memItemLeft" align="right" valign="top"><a id="ga2a4019f06050d48db420acb0811991d5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IEC60730__IRQ__TEST.html#ga2a4019f06050d48db420acb0811991d5">SL_IEC60730_IRQ_STATUS_ENABLE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga2a4019f06050d48db420acb0811991d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable using <a class="el" href="group__IEC60730__IRQ__TEST.html#gaa8774bcfe6f464cbfe6cfbf984e1a4b4">sl_iec60730_get_irq_index_failed()</a> function to get the value of failed irqs. <br /></td></tr>
<tr class="separator:ga2a4019f06050d48db420acb0811991d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5aedf3f99169144756ad1d5344b3ca9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IEC60730__IRQ__TEST.html#ga5aedf3f99169144756ad1d5344b3ca9e">sl_iec60730_irq_reset_fail_result</a> (void)</td></tr>
<tr class="separator:ga5aedf3f99169144756ad1d5344b3ca9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8774bcfe6f464cbfe6cfbf984e1a4b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsl__iec60730__irq__fail__t.html">sl_iec60730_irq_fail_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IEC60730__IRQ__TEST.html#gaa8774bcfe6f464cbfe6cfbf984e1a4b4">sl_iec60730_get_irq_index_failed</a> (void)</td></tr>
<tr class="separator:gaa8774bcfe6f464cbfe6cfbf984e1a4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4200cf75871325ffe9944dc013e06b6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IEC60730__IRQ__TEST.html#ga4200cf75871325ffe9944dc013e06b6f">sl_iec60730_irq_init</a> (<a class="el" href="structsl__iec60730__irq__cfg__t.html">sl_iec60730_irq_cfg_t</a> *irq_cfg_ptr)</td></tr>
<tr class="separator:ga4200cf75871325ffe9944dc013e06b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0af58fa8884fc05958ed44e9de254c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IEC60730__IRQ__TEST.html#ga5f0af58fa8884fc05958ed44e9de254c">sl_iec60730_irq_reset_counter</a> (void)</td></tr>
<tr class="separator:ga5f0af58fa8884fc05958ed44e9de254c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9689fa2d33a7424330a587a25926676"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IEC60730__IRQ__TEST.html#gae9689fa2d33a7424330a587a25926676">sl_iec60730_irq_check</a> (void)</td></tr>
<tr class="separator:gae9689fa2d33a7424330a587a25926676"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Verifies interrupt frequency is within bounds. </p>
<p>The interrupt plausibility test checks that enabled interrupts are executing at a frequency that is within expected minimum and maximum bounds every test timer period.</p>
<p>OEM firmware is responsible for setting expected minimum and maximum bounds for each enabled interrupt in the <b>oem_irq_freq_bounds</b> structure. The OEM is also responsible for incrementing the element in the <b>oem_irq_exec_count</b> array inside each enabled interrupt. In <a class="el" href="group__IEC60730__IRQ__TEST.html#gae9689fa2d33a7424330a587a25926676">sl_iec60730_irq_check()</a>, which executes as part of the test timer-driven tests of the BIST, this counter array is compared with the defined bounds to determine whether each interrupt is operating within safe parameters.</p>
<h1><a class="anchor" id="irq_hardware_architecture"></a>
Hardware Architecture</h1>
<p>Most hardware-implemented peripherals in Silicon Labs EFR32 devices offer the ability to vector to an interrupt service routine in order to quickly respond peripheral-related events and state updates.</p>
<p>In order to vector to an interrupt from executing foreground code, hardware pushes the program counter to the stack and vectors to a hardware-defined entry in a vector table stored in non-volatile memory in a region of Flash. The code of the interrupt service routine is either stored directly within this table entry, or stored elsewhere in memory and accessed through a jump instruction placed in the vector table, depending on the size of the interrupt service routine.</p>
<p>Once the function body of the interrupt service routine has completed executing, the program counter is pop from the stack and returns to foreground code to continue execution.</p>
<p>Each interrupt has a flag in a register that must be cleared inside the interrupt service routine function to signal that the interrupt has been processed in firmware. Failure to clear this flag inside the function body will result in the hardware immediately vectoring back to the interrupt.</p>
<h1><a class="anchor" id="irq_failure_risks"></a>
Failure Risks</h1>
<p>It is the OEM's responsibility to accurately estimate the frequency of each enabled interrupt in a firmware project. For interrupts that are asynchronous and may not execute at all within a test timer period, the lower bounds for the interrupt should be set to 0.</p>
<p>It is also the OEM's responsibility to increment values in <b>oem_irq_exec_count</b> once and only once per interrupt execution. Failure to include this incrementing command will result in an interrupt that appears to be executing below minimum defined bounds, which will force safe state entry.</p>
<p>The OEM should also be mindful of all hardware-related constraints of each interrupt. Failure to clear an interrupt flag inside an interrupt service routine will cause the routine to execute repeatedly, which will increment an <b>oem_irq_exec_count</b> entry beyond upper bounds and cause a safe state entry.</p>
<p>The OEM must also perform a bounds check on the element in <b>oem_irq_exec_count</b> being incremented to ensure that the counter does not exceed the upper bounds defined by its data type and overflow back to 0. Failure to perform this bounds check could have the effect of creating a passing IRQ plausibility test when the interrupt is actually running outside of defined limits.</p>
<h1><a class="anchor" id="irq_software_architecture"></a>
Software Architecture</h1>
<p>The interrupt plausibility test function relies on an array of counters called <b>oem_irq_exec_count</b>, stored in volatile memory and an array of struct <a class="el" href="structsl__iec60730__irq__execution__bounds__t.html">sl_iec60730_irq_execution_bounds_t</a> found in non-volatile memory and called oem_irq_freq_bounds. OEM firmware increments bytes in <b>oem_irq_exec_count</b> during execution of each enabled interrupt service routine. When the test timer interrupt occurs, <a class="el" href="group__IEC60730__IRQ__TEST.html#gae9689fa2d33a7424330a587a25926676">sl_iec60730_irq_check()</a> executes. Inside this function, firmware compares the count values to the bound values, and sets <b>iec60730_safety_check</b> by called function sl_iec60730_safety_check_error_occur to SL_IEC60730_INTERRUPT_FAIL if a count exceeds either the minimum or maximum bounds. The next execution of the BIST routine will detect the SL_IEC60730_TEST_FAILED state and enter safe state. A flowchart of this functionality is shown in <a class="el" href="group__IEC60730__IRQ__TEST.html#irq_plausibility_test_flowchart">Figure 1 </a>.</p>
<p>For more information on configuration of the test timer, please see <a class="el" href="group__IEC60730__SYSTEM__CLOCK__TEST.html">System Clock Check</a>.</p>
<p><a class="anchor" id="irq_plausibility_test_flowchart"></a></p><div class="image">
<img src="irq_plausibility_test_flowchart.png" alt=""/>
<div class="caption">
Figure 1 Flow chart of interrupt plausibility check</div></div>
 <h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaa427cc722316d7c8063ec6e66b21b978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa427cc722316d7c8063ec6e66b21b978">&#9670;&nbsp;</a></span>IEC60730_MAX_IRQ_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IEC60730_MAX_IRQ_CHECK&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of interrupted users that can be used for testing. The param passed to the init function <a class="el" href="group__IEC60730__IRQ__TEST.html#ga4200cf75871325ffe9944dc013e06b6f">sl_iec60730_irq_init()</a> must have a size value smaller than this value </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa8774bcfe6f464cbfe6cfbf984e1a4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8774bcfe6f464cbfe6cfbf984e1a4b4">&#9670;&nbsp;</a></span>sl_iec60730_get_irq_index_failed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsl__iec60730__irq__fail__t.html">sl_iec60730_irq_fail_t</a>* sl_iec60730_get_irq_index_failed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>public IEC60730 Get The Location Of The Failed IRQ</p>
<dl class="section return"><dt>Returns</dt><dd>pointer type <a class="el" href="structsl__iec60730__irq__fail__t.html">sl_iec60730_irq_fail_t</a> point to variable containing the errors that occurred and the number of errors</dd></dl>
<p>This function return a <b>iec60730_irq_fail_result</b>. That variable contains the number of failed irq checks and stores the failed interrupt value in bits. </p>

</div>
</div>
<a id="gae9689fa2d33a7424330a587a25926676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9689fa2d33a7424330a587a25926676">&#9670;&nbsp;</a></span>sl_iec60730_irq_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sl_iec60730_irq_check </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>public IEC60730 Interrupt Plausibility Check</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>This function compares each entry in <b>oem_irq_exec_count</b> with its corresponding bounds defined in <b>oem_irq_freq_bounds</b>. If the entry is found to exceed the defined bounds, <b>iec60730_safety_check</b> is set to <a class="el" href="group__sl__iec60730__post.html#ggaf7c222de19839be183a43b0a7cc8fe15a6fb86661df7f82d9612f47d8b2f66be8" title="Interrupt Plausibility Check detected a failure.">SL_IEC60730_INTERRUPT_FAIL</a>. Otherwise no action is taken. The function ends by setting <a class="el" href="group__IEC60730__PROGRAM__COUNTER.html#ga33e80e609861bd9b4907bcc349154d2e" title="Mask bit used for Interrupt Checks completed.">IEC60730_INTERRUPT_COMPLETE</a>. </p>

</div>
</div>
<a id="ga4200cf75871325ffe9944dc013e06b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4200cf75871325ffe9944dc013e06b6f">&#9670;&nbsp;</a></span>sl_iec60730_irq_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sl_iec60730_irq_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl__iec60730__irq__cfg__t.html">sl_iec60730_irq_cfg_t</a> *&#160;</td>
          <td class="paramname"><em>irq_cfg_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>public IEC60730 Interrupt Init</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irq_cfg_ptr</td><td>input pointer point to value config by user</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>This function set a pointer point to address <b>oem_irq_freq_bounds</b> min and max and <b>oem_irq_exec_count</b>. To initialize test values ​​for the <a class="el" href="group__IEC60730__IRQ__TEST.html#gae9689fa2d33a7424330a587a25926676">sl_iec60730_irq_check()</a> function. </p>

</div>
</div>
<a id="ga5f0af58fa8884fc05958ed44e9de254c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f0af58fa8884fc05958ed44e9de254c">&#9670;&nbsp;</a></span>sl_iec60730_irq_reset_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sl_iec60730_irq_reset_counter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>public IEC60730 Interrupt Reset Counter</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>This function reset counter <b>oem_irq_exec_count</b> to 0 </p>

</div>
</div>
<a id="ga5aedf3f99169144756ad1d5344b3ca9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5aedf3f99169144756ad1d5344b3ca9e">&#9670;&nbsp;</a></span>sl_iec60730_irq_reset_fail_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sl_iec60730_irq_reset_fail_result </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>public IEC60730 Reset IRQ Failed Results</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>This function reset local counter irq fail <b>iec60730_irq_fail_result</b> to 0 </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
